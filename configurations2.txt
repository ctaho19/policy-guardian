import xml.etree.ElementTree as ET
from difflib import SequenceMatcher
import sys

# Function to extract application names from Mac OS XML
def extract_mac_apps(xml_file):
    apps = []
    try:
        tree = ET.parse(xml_file)
        root = tree.getroot()
        for app_group in root.findall(".//ApplicationGroupOSX"):
            for app in app_group.findall(".//ApplicationOSX"):
                # Extract identifiers
                filename = app.get("FileName", "")
                desc = app.get("Description", "")
                app_type = app.get("Type", "")
                # Use filename or description as the app name; skip wildcards unless specific
                if filename and filename != "*":
                    apps.append(filename.lower())
                elif desc and "Any" not in desc:  # Avoid generic "Any macOS Binary" entries
                    apps.append(desc.lower())
                # Add more fields if needed (e.g., URI, CertificateString)
        return apps
    except ET.ParseError as e:
        print(f"Error parsing {xml_file}: {e}")
        return []

# Function to extract application names from Windows XML
def extract_windows_apps(xml_file):
    apps = []
    try:
        tree = ET.parse(xml_file)
        root = tree.getroot()
        for app_group in root.findall(".//ApplicationGroup"):
            for app in app_group.findall(".//Application"):
                # Extract identifiers
                filename = app.get("FileName", "")
                desc = app.get("Description", "")
                app_type = app.get("Type", "")
                service_name = app.get("ServiceName", "")
                appx_name = app.get("AppxPackageName", "")
                # Use filename, description, or other fields; skip wildcards unless specific
                if filename and filename != "*":
                    apps.append(filename.lower())
                elif desc and "Any" not in desc:
                    apps.append(desc.lower())
                elif service_name and service_name != "*":
                    apps.append(service_name.lower())
                elif appx_name and appx_name != "*":
                    apps.append(appx_name.lower())
        return apps
    except ET.ParseError as e:
        print(f"Error parsing {xml_file}: {e}")
        return []

# Function for partial matching
def is_partial_match(blocked_app, xml_app, threshold=0.75):
    return SequenceMatcher(None, blocked_app.lower(), xml_app.lower()).ratio() >= threshold

# Main comparison function
def compare_blocklist_with_xml(blocklist_file, windows_xml, mac_xml):
    # Read blocklist
    with open(blocklist_file, 'r') as f:
        blocklist = [line.strip().lower() for line in f if line.strip()]

    # Extract apps from XML files
    windows_apps = extract_windows_apps(windows_xml)
    mac_apps = extract_mac_apps(mac_xml)
    all_apps = set(windows_apps + mac_apps)

    # Compare blocklist with XML apps
    found = []
    not_found = []

    for blocked_app in blocklist:
        matched = False
        for xml_app in all_apps:
            if is_partial_match(blocked_app, xml_app):
                found.append((blocked_app, xml_app))
                matched = True
                break
        if not matched:
            not_found.append(blocked_app)

    # Output results
    print("\nApplications from blocklist found in XML policies:")
    for b_app, x_app in found:
        print(f"Blocklist: '{b_app}' -> Matched in XML: '{x_app}'")

    print("\nApplications from blocklist NOT found in XML policies:")
    for app in not_found:
        print(f"'{app}'")

    return found, not_found

# Example usage
if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python script.py blocklist.txt windows.xml mac.xml")
        sys.exit(1)

    blocklist_file = sys.argv[1]
    windows_xml = sys.argv[2]
    mac_xml = sys.argv[3]

    compare_blocklist_with_xml(blocklist_file, windows_xml, mac_xml)
