import requests
import logging
import time
from typing import List

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),  # Console output
        logging.FileHandler('pagination_test.log')  # File output
    ]
)
logger = logging.getLogger(__name__)

# API Configuration
BASE_URL = "https://api.cloud.[company].com/internal-operations/cloud-service/aws-tooling/search-resource-configurations"
HEADERS = {
    "Accept": "application/json;v=1.0",
    "Authorization": "Bearer your_actual_token_here",  # Replace with your token
    "Content-Type": "application/json"
}

def paginate_resources(page_size: int = 10000, max_pages: int = 50) -> List[dict]:
    """
    Test pagination with nextRecordKey using the real API.

    Args:
        page_size: Number of resources per page (max 10000 per API owners)
        max_pages: Safety limit to prevent infinite loops

    Returns:
        List of resource dictionaries
    """
    all_resources = []
    unique_resource_ids = set()  # Track duplicates
    next_record_key = ""
    page_count = 0
    consecutive_empty_pages = 0
    max_consecutive_empty = 2

    # Base payload with responseFields (no limit here)
    payload = {
        "searchParameters": [{"resourceType": "AWS::KMS::Key"}],
        "responseFields": [
            "accountName", "accountResourceId", "amazonResourceName", "asvName",
            "awsAccountId", "awsRegion", "businessApplicationName",
            "environment", "resourceCreationTimestamp", "resourceId",
            "resourceType", "configurationList", "configuration.origin"
        ]
    }

    logger.info(f"Starting pagination with page_size={page_size}")

    while True:
        current_page_key = next_record_key
        logger.info(f"Fetching page {page_count + 1} with nextRecordKey: '{next_record_key or 'None'}'")

        # Add nextRecordKey to payload if present
        if next_record_key:
            payload["nextRecordKey"] = next_record_key

        # Set limit as URL parameter
        params = {"limit": min(page_size, 10000)}  # Cap at API max

        try:
            response = requests.post(
                BASE_URL,
                headers=HEADERS,
                json=payload,
                params=params,  # Add limit as query parameter
                timeout=60,
                verify=False
            )
            response.raise_for_status()
            data = response.json()
            resources = data.get("resourceConfigurations", [])
            new_next_record_key = data.get("nextRecordKey", "")

            logger.info(f"Page {page_count + 1}: {len(resources)} resources, nextRecordKey: '{new_next_record_key or 'None'}'")

            # Handle empty pages
            if not resources:
                consecutive_empty_pages += 1
                logger.warning(f"Empty page detected ({consecutive_empty_pages}/{max_consecutive_empty})")
                if consecutive_empty_pages >= max_consecutive_empty:
                    logger.error("Too many consecutive empty pages, stopping")
                    break
            else:
                consecutive_empty_pages = 0

            # Process resources
            for resource in resources:
                resource_id = resource.get("resourceId")
                if resource_id in unique_resource_ids:
                    logger.warning(f"Duplicate resource found: {resource_id}")
                    continue
                unique_resource_ids.add(resource_id)
                all_resources.append(resource)

            # Check for duplicate nextRecordKey
            if new_next_record_key == current_page_key and current_page_key:
                logger.warning(f"Duplicate nextRecordKey '{new_next_record_key}' detected, stopping")
                break

            # Update nextRecordKey
            next_record_key = new_next_record_key

            # Stop if no more pages
            if not next_record_key:
                logger.info("No nextRecordKey, pagination complete")
                break

            page_count += 1
            if page_count >= max_pages:
                logger.error(f"Hit max pages ({max_pages}), stopping")
                break

        except requests.exceptions.RequestException as e:
            logger.error(f"API request failed: {e}")
            break

        time.sleep(0.5)  # Avoid overwhelming the API

    logger.info(f"Pagination complete: {len(all_resources)} resources in {page_count + 1} pages")
    return all_resources

def main():
    """Run the pagination test and display results."""
    resources = paginate_resources(page_size=10000)
    
    print("\nResults:")
    print(f"Total Resources: {len(resources)}")
    if resources:
        print("First resource sample:")
        sample = resources[0]
        print(f"Resource ID: {sample.get('resourceId')}")
        print(f"AWS Account ID: {sample.get('awsAccountId')}")
        print(f"Region: {sample.get('awsRegion')}")
        # Extract origin from configurationList
        origin = "Unknown"
        for config in sample.get("configurationList", []):
            if config.get("configurationName") == "configuration.origin":
                origin = config.get("configurationValue")
                break
        print(f"Origin: {origin}")

if __name__ == "__main__":
    main()
