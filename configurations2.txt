def fetch_all_resources(payload: Dict, limit: Optional[int] = None, validate_only: bool = False, 
                       timeout: int = 60, max_retries: int = 3) -> Tuple[List[Dict], int]:
    """
    Fetch resources with pagination, timeout, and retry logic.
    """
    all_resources = []
    total_count = 0
    next_record_key = None  # Changed from empty string to None
    
    # Restructure the fetch payload to match API expectations
    fetch_payload = {
        "responseFields": [
            "accountName", "accountResourceId", "amazonResourceName", "asvName", 
            "awsAccountId", "awsRegion", "businessApplicationName", 
            "environment", "resourceCreationTimestamp", "resourceId", 
            "resourceType", "supplementaryConfiguration",
            "supplementaryConfiguration.KeyRotationStatus"
        ],
        "searchParameters": payload.get("searchParameters", [])
    }
    
    if limit:
        fetch_payload["limit"] = min(limit, 10000)
    
    logger.info(f"Fetching resources with initial payload: {json.dumps(fetch_payload, indent=2)}")
    page_count = 0
    start_time = datetime.now()

    while True:
        try:
            current_url = CONFIG_URL
            if next_record_key:
                current_url = f"{CONFIG_URL}?nextRecordKey={next_record_key}"

            response = requests.post(
                current_url,
                headers=HEADERS,
                json=fetch_payload,  # Changed from data to json
                verify=False,
                timeout=timeout
            )

            if response.status_code == 502:
                logger.error(f"Bad Gateway (502) received. Response: {response.text}")
                if page_count == 0:
                    raise Exception("Initial request failed with 502")
                break  # If we've already got some data, break and return what we have

            response.raise_for_status()
            data = response.json()
            
            resources = data.get("resourceConfigurations", [])
            all_resources.extend(resources)
            total_count += len(resources)
            
            next_record_key = data.get("nextRecordKey")
            page_count += 1
            
            logger.info(f"Page {page_count}: Fetched {len(resources)} resources, total: {total_count}")
            
            if validate_only or not next_record_key or (limit and total_count >= limit):
                break

        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed: {str(e)}")
            if page_count == 0:
                raise  # Fail if we haven't got any data yet
            break  # Otherwise return what we have

    total_time = (datetime.now() - start_time).total_seconds()
    logger.info(f"Fetch complete: {total_count} resources in {page_count} pages, {total_time:.1f} seconds")
    return all_resources, total_count
