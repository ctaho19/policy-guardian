WITH Violation_Raw AS (
    SELECT
        RESOURCE_NAME,
        ROLE_TYPE,
        CREATE_DATE,
        ROW_NUMBER() OVER (PARTITION BY RESOURCE_NAME ORDER BY CREATE_DATE DESC) AS rn
    FROM EIAM_DB.PHDP_CYBR_IAM.IDENTITY_REPORTS_CONTROLS_VIOLATIONS_STREAM_V2
),
Violation_Roles AS (
    SELECT
        RESOURCE_NAME,
        ROLE_TYPE
    FROM Violation_Raw
    WHERE rn = 1
),
IAM_Roles AS (
    SELECT 
        RESOURCE_ID,
        AMAZON_RESOURCE_NAME,
        BA,
        ACCOUNT,
        CREATE_DATE
    FROM EIAM_DB.PHDP_CYBR_IAM.IDENTITY_REPORTS_IAM_RESOURCE
    WHERE TYPE = 'role'
      AND AMAZON_RESOURCE_NAME LIKE 'arn:aws:iam::%role/%'
)
-- Do the join first, then use an aggregation/grouping to ensure that if any row for a given ARN maps, you get that mapping.
SELECT 
    MIN(r.RESOURCE_ID) AS RESOURCE_ID,
    r.AMAZON_RESOURCE_NAME,
    MAX(r.BA) AS BA,
    MAX(r.ACCOUNT) AS ACCOUNT,
    COALESCE(MAX(v.ROLE_TYPE), 'NOT FOUND') AS ASSIGNED_ROLE_TYPE
FROM IAM_Roles r
LEFT JOIN Violation_Roles v
    ON r.AMAZON_RESOURCE_NAME = v.RESOURCE_NAME
GROUP BY r.AMAZON_RESOURCE_NAME;
