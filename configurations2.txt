def fetch_all_resources(payload: Dict, limit: Optional[int] = None, validate_only: bool = False, 
                        timeout: int = 60, max_retries: int = 3) -> Tuple[List[Dict], int]:
    all_resources = []
    total_count = 0
    next_record_key = ""
    fetch_payload = {
        "searchParameters": [payload.get("searchParameters", {})],
        "responseFields": [
            "accountName", "accountResourceId", "amazonResourceName", "asvName", 
            "awsAccountId", "awsRegion", "businessApplicationName", 
            "environment", "resourceCreationTimestamp", "resourceId", 
            "resourceType", "configurationList",
            "configuration.origin"
        ],
        "limit": min(limit, 10000) if limit else 10000
    }
    
    if next_record_key:
        fetch_payload["nextRecordKey"] = next_record_key
    
    display_log(f"Fetching resources with payload: {json.dumps(fetch_payload, indent=2)}")
    
    page_count = 0
    start_time = datetime.now()
    
    while True:
        for retry in range(max_retries + 1):
            try:
                logger.info(f"Requesting page {page_count + 1}" + (f" (retry {retry})" if retry > 0 else ""))
                response = requests.post(
                    CONFIG_URL,  # Don't modify the URL
                    headers=HEADERS,
                    data=json.dumps(fetch_payload),  # Match get_summary_count approach
                    verify=False,
                    timeout=timeout
                )
                
                if response.status_code == 200:
                    data = response.json()
                    resources = data.get("resourceConfigurations", [])
                    
                    if page_count == 0:
                        logger.debug(f"First page response structure: {json.dumps(data, indent=2)}")
                        if resources:
                            logger.debug(f"Sample resource structure: {json.dumps(resources[0], indent=2)}")
                    
                    all_resources.extend(resources)
                    total_count += len(resources)
                    next_record_key = data.get("nextRecordKey", "")
                    
                    if next_record_key:
                        fetch_payload["nextRecordKey"] = next_record_key  # Update payload instead of URL
                    
                    logger.info(f"Page {page_count + 1}: Fetched {len(resources)} resources, total: {total_count}")
                    
                    page_count += 1
                    break
                    
                elif response.status_code == 502:
                    logger.error(f"Bad Gateway (502) error. Response: {response.text}")
                    if retry == max_retries:
                        raise Exception(f"Failed after {max_retries} retries due to Bad Gateway")
                    wait_time = min(2 ** retry, 30)
                    logger.warning(f"Waiting {wait_time}s before retry...")
                    time.sleep(wait_time)
                    
                elif response.status_code != 200:
                    logger.error(f"API error: {response.status_code} - {response.text}")
                    if retry == max_retries:
                        raise Exception(f"Failed after {max_retries} retries")
                    time.sleep(min(2 ** retry, 30))
                    
            except Exception as e:
                logger.error(f"Request failed: {str(e)}")
                if retry == max_retries:
                    raise Exception(f"Failed after {max_retries} retries")
                time.sleep(min(2 ** retry, 30))
        
        if validate_only or not next_record_key or (limit and total_count >= limit):
            break
    
    total_time = (datetime.now() - start_time).total_seconds()
    logger.info(f"Fetch complete: {total_count} resources in {page_count} pages, {total_time:.1f} seconds")
    return all_resources, total_count
