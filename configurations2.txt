    # Step 4: Create initial mapping with full role information
    log_step("Creating initial role mapping")
    df_initial_mapping = df_all_iam_roles.alias("roles") \
        .join(
            df_violation_roles.alias("violations"),
            df_all_iam_roles["AMAZON_RESOURCE_NAME"] == df_violation_roles["RESOURCE_NAME"],
            "left"
        ) \
        .join(
            df_evaluated_roles.alias("evaluated"),
            df_all_iam_roles["AMAZON_RESOURCE_NAME"] == df_evaluated_roles["RESOURCE_NAME"],
            "left"
        ) \
        .select(
            col("roles.RESOURCE_ID"),
            col("roles.AMAZON_RESOURCE_NAME"),
            col("roles.BA"),
            col("roles.ACCOUNT"),
            col("roles.CREATE_DATE"),
            col("roles.LOAD_TIMESTAMP"),
            coalesce(col("violations.ROLE_TYPE"), lit("NOT FOUND")).alias("ROLE_TYPE"),
            when(col("evaluated.RESOURCE_NAME").isNotNull(), 1).otherwise(0).alias("IS_EVALUATED"),
            lit("INITIAL_MAPPING").alias("MAPPING_SOURCE")
        )


# Step 5: Find unmapped resources
log_step("Finding unmapped resources")
df_unmapped = df_all_iam_roles.alias("all_roles").join(
    df_initial_mapping.alias("initial_mapping"),
    col("all_roles.RESOURCE_ID") == col("initial_mapping.RESOURCE_ID"),
    "left_anti"
)
log_step("Unmapped resources identified", f"Unmapped Roles: {df_unmapped.count()}")

# Step 6: Check unmapped resources in violations dataset
log_step("Validating unmapped resources")
df_unmapped_validation = df_unmapped.alias("unmapped").join(
    df_violation_roles.alias("violations"),
    col("unmapped.AMAZON_RESOURCE_NAME") == col("violations.RESOURCE_NAME"),
    "left"
).select(
    col("unmapped.RESOURCE_ID"),
    col("unmapped.AMAZON_RESOURCE_NAME"),
    col("unmapped.BA"),
    col("unmapped.ACCOUNT"),
    col("unmapped.CREATE_DATE"),
    col("unmapped.LOAD_TIMESTAMP"),
    coalesce(col("violations.ROLE_TYPE"), lit("NOT FOUND")).alias("ROLE_TYPE"),
    lit(0).alias("IS_EVALUATED"),
    lit("VALIDATION_MAPPING").alias("MAPPING_SOURCE")
)


# Step 9: Join with approved accounts
log_step("Filtering for approved accounts")
df_filtered = df_machine_roles.alias("machine_roles").join(
    df_approved_accounts.alias("approved_accounts"),
    upper(col("machine_roles.ACCOUNT")) == upper(col("approved_accounts.accountNumber")),
    "inner"
).select(
    col("machine_roles.*")  # Select all columns from machine_roles
)
log_step("Account filtering complete", 
         f"Machine Roles in Approved Accounts: {df_filtered.count()}")



# Get non-compliant roles
df_tier2_evidence = evaluated_roles.alias("eval_roles").filter(~col("eval_roles.COMPLIANCE_STATUS").rlike("^Compliant.*")) \
    .select(
        col("eval_roles.RESOURCE_ID"),
        col("eval_roles.AMAZON_RESOURCE_NAME").alias("ARN"),
        col("eval_roles.ACCOUNT"),
        col("eval_roles.BA"),
        col("eval_roles.CREATE_DATE"),
        col("eval_roles.ROLE_TYPE"),
        col("eval_roles.COMPLIANCE_STATUS").alias("NOTES")
    ) \
    .orderBy(["ACCOUNT", "ARN"])
