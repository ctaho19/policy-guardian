Yes, I’m familiar with Amazon QuickSight’s integration of Highcharts and the specific syntax required for creating custom visuals using Highcharts JSON in QuickSight. QuickSight’s Highcharts visual requires a valid JSON schema that adheres to certain constraints (e.g., no JavaScript functions, no external references, and the use of QuickSight-specific expressions like getColumn to reference dataset fields dynamically). The error you’re encountering—“Expected a JSON object, array or literal”—suggests that QuickSight is interpreting your input as invalid JSON, likely because it resembles JavaScript code rather than a pure JSON object.
Why the Error Occurs
Your current code is written in a JavaScript format (Highcharts.chart(...)), which works in a typical Highcharts environment but not in QuickSight. In QuickSight, the Highcharts visual expects a standalone JSON object without the Highcharts.chart() wrapper or any executable JavaScript syntax (like function calls or dynamic formatting). Additionally, to make the chart dynamic with your dataset (containing “Aggregated Status” and a calculated field for distinct ctrl_ids), you need to use QuickSight expressions like getColumn to map your data fields into the chart.
Fixing the Code
Let’s adjust your code to:
	1	Convert it to a valid JSON object compatible with QuickSight.
	2	Incorporate your dataset fields (“Aggregated Status” and the distinct count of ctrl_ids) dynamically using QuickSight expressions.
	3	Ensure the structure aligns with Highcharts’ pie chart requirements.
Here’s a corrected version of your JSON schema for QuickSight:
{
    "chart": {
        "type": "pie"
    },
    "title": {
        "text": "DISTRIBUTION BREAKDOWN: PERCENTAGE SPLIT BY COMPLIANCE STATUS"
    },
    "tooltip": {
        "valueSuffix": "%"
    },
    "plotOptions": {
        "pie": {
            "allowPointSelect": true,
            "cursor": "pointer",
            "dataLabels": [
                {
                    "enabled": true,
                    "distance": 20
                },
                {
                    "enabled": true,
                    "distance": -40,
                    "format": "{point.percentage:.1f}%",
                    "style": {
                        "fontSize": "1.2em",
                        "textOutline": "none",
                        "opacity": 0.7
                    },
                    "filter": {
                        "operator": ">",
                        "property": "percentage",
                        "value": 10
                    }
                }
            ]
        }
    },
    "series": [
        {
            "name": "Percentage",
            "colorByPoint": true,
            "data": {
                "type": "array",
                "values": [
                    ["getColumn", 0],
                    ["getColumn", 1]
                ]
            }
        }
    ]
}
Key Changes and Explanations
	1	Removed Highcharts.chart() Wrapper:
	◦	QuickSight doesn’t execute JavaScript; it only accepts a JSON configuration. The Highcharts.chart('container', ...) syntax is removed, leaving just the configuration object.
	2	Dynamic Data with getColumn:
	◦	Instead of hardcoding static data (name: 'AGGREGATED_STATUS', y: 55.02), I’ve used QuickSight’s getColumn expression to reference your dataset fields dynamically.
	◦	"getColumn", 0 maps to your first field (assumed to be “Aggregated Status”).
	◦	"getColumn", 1 maps to your second field (assumed to be the distinct count of ctrl_ids).
	◦	QuickSight expects your dataset to have two columns: one for the category (e.g., “red”, “yellow”, “green”) and one for the measure (e.g., distinct count of ctrl_ids). Ensure your dataset is structured this way in QuickSight.
	3	Data Structure:
	◦	The data property in the series object uses QuickSight’s array format ("type": "array", "values": [...]) to pull in the columns directly. QuickSight will interpret these as [name, y] pairs for the pie chart, where name is the category (e.g., “red”, “yellow”, “green”) and y is the value (e.g., the count).
	4	JSON Compliance:
	◦	Removed any JavaScript-specific syntax (e.g., function definitions). QuickSight validates the JSON in real-time and will flag errors if it’s not a pure object, array, or literal.
Assumptions About Your Dataset
	•	Column 0: “Aggregated Status” (e.g., “red”, “yellow”, “green”).
	•	Column 1: A calculated field with the distinct count of ctrl_ids for each status.
	•	Your dataset is grouped by “Aggregated Status” with the distinct count pre-calculated in QuickSight (e.g., via a calculated field like distinctCount(ctrl_ids)).
If your dataset structure differs (e.g., the fields are in a different order or not pre-aggregated), let me know, and I can adjust the indices in getColumn.
Steps to Implement
	1	Prepare Your Dataset:
	◦	In QuickSight, ensure your dataset has two columns:
	▪	One for “Aggregated Status” (categorical: “red”, “yellow”, “green”).
	▪	One for the distinct count of ctrl_ids (numeric, pre-calculated using a calculated field if needed).
	◦	Example dataset: Aggregated Status | Distinct Count of ctrl_ids
	◦	------------------|---------------------------
	◦	red              | 50
	◦	yellow           | 30
	◦	green            | 20
	◦	
	2	Add the Highcharts Visual:
	◦	In your QuickSight analysis, add a Highcharts visual.
	◦	Drag “Aggregated Status” to the “Group/Color” field well and the distinct count field to the “Value” field well.
	3	Paste the JSON:
	◦	Open the “Chart code” section in the Highcharts visual properties.
	◦	Paste the JSON schema above into the editor.
	◦	QuickSight will validate it and render the pie chart if the syntax and data mapping are correct.
	4	Troubleshooting:
	◦	If you see the same error (“Expected a JSON object, array or literal”), double-check for trailing commas or syntax issues in the JSON.
	◦	If the chart doesn’t render as expected, verify your dataset fields align with getColumn indices (0 and 1).
Additional Notes
	•	Colors: Since you mentioned “red, yellow, green,” the colorByPoint: true setting will automatically assign different colors to each slice. QuickSight uses its default theme colors, but you can’t specify exact colors (e.g., #FF0000 for red) directly in the JSON due to limitations.
	•	Percentages: The format: '{point.percentage:.1f}%' ensures percentages display as intended, with the filter (> 10) hiding labels for small slices.
Let me know if you encounter issues or need further tweaks based on your specific dataset!

